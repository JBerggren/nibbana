// Generated by CoffeeScript 1.3.3
(function() {
  var EntityMap, Session, constants, jq, util, uuid;

  uuid = require('node-uuid');

  jq = require('jquery');

  util = require('./util');

  constants = require('./constants');

  EntityMap = require('./entity_map');

  Session = (function() {

    function Session(storage) {
      var _this = this;
      this.base_url = "https://api.nirvanahq.com/";
      this.authtoken = false;
      this.lastupdate = 0;
      this.common_url_params = {
        api: "rest",
        requestid: function() {
          return uuid.v4();
        },
        clienttime: function() {
          return util.unix_time();
        },
        authtoken: function() {
          return _this.authtoken;
        },
        appid: "nirvanahqjs",
        appversion: 0
      };
      this.method_map = {
        login: {
          method: 'POST',
          data: {
            method: "auth.new",
            u: function(params) {
              return params.username || (function() {
                throw new Error("Username required to login");
              })();
            },
            p: function(params) {
              return params.password || (function() {
                throw new Error("MD5 hash of password required to login");
              })();
            },
            gmtoffset: new Date().getTimezoneOffset() / -60
          }
        },
        logout: {
          method: 'POST',
          data: {
            method: "auth.destroy"
          }
        },
        everything: {
          method: 'GET',
          url_params: {
            method: "everything",
            since: function(params) {
              return params.since || 0;
            }
          }
        },
        save_task: {
          method: 'POST',
          data: {
            method: "task.save"
          }
        },
        save_tag: {
          method: 'POST',
          data: {
            method: "tag.save"
          }
        }
      };
      this.storage = storage;
      if (this.storage.has("authtoken")) {
        this.authenticate(this.storage.get("authtoken"));
      }
    }

    Session.prototype._request_error = function(message, deferred) {
      var _this = this;
      return function(data) {
        if (deferred) {
          deferred.reject();
        }
        throw new Error("" + message + " (" + data.status + " : " + data.statusText + ")");
      };
    };

    Session.prototype._make_request = function(mapped_method, params) {
      var data, jqdata, k, mapping, param, payload, url_params, v, _i, _len, _ref;
      url_params = jq.extend({}, this.common_url_params);
      mapping = this.method_map[mapped_method];
      if (mapping.url_params) {
        _ref = mapping.url_params;
        for (k in _ref) {
          v = _ref[k];
          url_params[k] = v;
        }
      }
      for (k in url_params) {
        v = url_params[k];
        if (typeof v === "function") {
          url_params[k] = v(params);
        }
      }
      jqdata = {
        type: mapping.method
      };
      if (params.length !== void 0) {
        jqdata.contentType = "application/json";
        payload = [];
        for (_i = 0, _len = params.length; _i < _len; _i++) {
          param = params[_i];
          data = mapping.data ? jq.extend({}, mapping.data) : {};
          for (k in param) {
            v = param[k];
            data[k] = v;
          }
          for (k in data) {
            v = data[k];
            if (typeof v === "function") {
              data[k] = v(param);
            }
          }
          payload.push(data);
        }
        payload = JSON.stringify(payload);
        url_params.api = "json";
      } else {
        payload = mapping.data ? jq.extend({}, mapping.data) : {};
        for (k in params) {
          v = params[k];
          payload[k] = v;
        }
        for (k in data) {
          v = data[k];
          if (typeof v === "function") {
            payload[k] = v(params);
          }
        }
      }
      jqdata.data = payload;
      jqdata.url = "" + this.base_url + "?" + (jq.param(url_params));
      return jq.ajax(jqdata).done(function(response) {
        if (response.results && response.results[0].error) {
          throw new Error("" + response.results[0].error.code + " : " + response.results[0].error.message);
        }
      });
    };

    Session.prototype.authenticate = function(username, password, opts) {
      var dfd,
        _this = this;
      if (opts == null) {
        opts = {};
      }
      dfd = new jq.Deferred;
      dfd.done(function(token) {
        return _this.authtoken = token;
      });
      dfd.done(function(token) {
        return _this.storage.set("authtoken", token, false);
      });
      if (!password) {
        dfd.resolve(username);
        return this.authenticated = dfd.promise();
      }
      this._make_request("login", {
        username: username,
        password: password
      }).done(function(data) {
        return dfd.resolve(data.result[0].auth.token);
      }).fail(this._request_error("Could not authenticate!", dfd));
      return this.authenticated = dfd.promise();
    };

    Session.prototype.destroy = function() {
      var _this = this;
      return this._make_request("logout").done(function() {
        return _this.authtoken = null;
      }).done(function() {
        return _this.storage.remove("authtoken");
      }).fail(this._request_error("Could not logout!"));
    };

    Session.prototype.store = function(model) {
      return this.storage.set(model.store_key(), model);
    };

    Session.prototype.sync = function() {
      var data, dfd, dirty, k, key, payloads, tag_dfd, task_dfd, _i, _len,
        _this = this;
      dfd = new jq.Deferred;
      task_dfd = new jq.Deferred;
      tag_dfd = new jq.Deferred;
      dirty = this.storage.dirty;
      payloads = {
        task: [],
        tag: []
      };
      for (_i = 0, _len = dirty.length; _i < _len; _i++) {
        k = dirty[_i];
        data = this.storage.get(k).get_data();
        delete data.__internal_type;
        key = data.type === constants.task.type.TASK || data.type === constants.task.type.PROJECT ? "task" : "tag";
        payloads[key].push(data);
      }
      if (payloads.task.length > 0) {
        this._make_request("save_task", payloads.task).done(function(data) {
          _this._cache_results(data.results);
          return task_dfd.resolve(data);
        });
      } else {
        task_dfd.resolve();
      }
      if (payloads.tag.length > 0) {
        this._make_request("save_tag", payloads.tag).done(function(data) {
          _this._cache_results(data.results);
          return tag_dfd.resolve(data);
        });
      } else {
        tag_dfd.resolve();
      }
      jq.when(tag_dfd, task_dfd).then(function() {
        _this.storage.clear_dirty();
        return dfd.resolve();
      });
      return dfd.promise();
    };

    Session.prototype.update = function(since) {
      var dfd, success,
        _this = this;
      if (since == null) {
        since = null;
      }
      if (since === null) {
        since = this.lastupdate;
      }
      dfd = new jq.Deferred;
      success = function(data) {
        _this.lastupdate = util.unix_time();
        _this._cache_results(data.results);
        return dfd.resolve(data.results);
      };
      this._make_request("everything", {
        since: since
      }).done(success).fail(this._request_error("Could not fetch data!", dfd));
      return dfd.promise();
    };

    Session.prototype._cache_results = function(results) {
      var m, r, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = results.length; _i < _len; _i++) {
        r = results[_i];
        if (r.user) {
          m = {
            get_data: function() {
              return r.user;
            },
            store_key: function() {
              return "user-" + r.user.id;
            }
          };
        } else if (r.task && r.task.type) {
          m = new EntityMap["task" + r.task.type](r.task);
        } else if (r.tag && r.tag.type) {
          m = new EntityMap["tag" + r.tag.type](r.tag);
        } else {
          continue;
        }
        _results.push(this.store(m));
      }
      return _results;
    };

    return Session;

  })();

  module.exports = Session;

}).call(this);
